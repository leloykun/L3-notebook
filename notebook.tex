  \documentclass[8pt,a4paper,landscape,oneside]{amsart}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{fullpage}
%\usepackage{geometry}
% \usepackage[top=0pt, bottom=1cm, left=0.3cm, right=0.3cm]{geometry}
\usepackage[top=3pt, bottom=1cm, left=0.3cm, right=0.3cm]{geometry}
\usepackage{graphicx}
% \usepackage{listings}
\usepackage{subcaption}
\usepackage[scaled]{beramono}
\usepackage{titling}
\usepackage{datetime}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{bookmark}

\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.1em\vspace{-1em}}%
}

% Minted
\usepackage{minted}
\newcommand{\code}[1]{\inputminted[fontsize=\normalsize,baselinestretch=1]{cpp}{_code/#1}}
\newcommand{\bashcode}[1]{\inputminted{bash}{_code/#1}}
\newcommand{\regcode}[1]{\inputminted{cpp}{code/#1}}

% Header/Footer
% \geometry{includeheadfoot}
%\fancyhf{}
\pagestyle{fancy}
\lhead{Ateneo de Manila University}
\rhead{\thepage}
\cfoot{}
\setlength{\headheight}{15.2pt}
\setlength{\droptitle}{-20pt}
\posttitle{\par\end{center}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Math and bit operators
\DeclareMathOperator{\lcm}{lcm}
\newcommand*\BitAnd{\mathrel{\&}}
\newcommand*\BitOr{\mathrel{|}}
\newcommand*\ShiftLeft{\ll}
\newcommand*\ShiftRight{\gg}
\newcommand*\BitNeg{\ensuremath{\mathord{\sim}}}
\DeclareRobustCommand{\stirling}{\genfrac\{\}{0pt}{}}

\newenvironment{myitemize}
{ \begin{itemize}[leftmargin=.5cm]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{itemize}                  }

% Title/Author
\title{$AdMU Progvar$}
\subtitle{Team Notebook}
\date{\ddmmyyyydate{\today{}}}

% Output Verbosity
\newif\ifverbose
\verbosetrue
% \verbosefalse

\begin{document}

\begin{multicols*}{3}
\maketitle
\thispagestyle{fancy}
\vspace{-3em}
% \addtocontents{toc}{\protect\enlargethispage{\baselineskip}}
\tableofcontents

% \clearpage

\section{Code Templates}
	\code{header.cpp}
\section{Data Structures}
  \subsection{Union Find}
    \code{data-structures/union_find.cpp}
  \subsection{Fenwick Tree}
		\subsubsection{Fenwick Tree w/ Point Queries}
			\code{data-structures/fenwick.cpp}
    \subsubsection{Fenwick Tree w/ Max Queries}
      \code{data-structures/fenwick_max.cpp}
  \subsection{Segment Tree}
    \subsubsection{Recursive, Point-update Segment Tree}
      \code{data-structures/segtree_rec_PU_RQ.cpp}
    \subsubsection{Iterative, Point-update Segment Tree}
      \code{data-structures/segtree_iter_PU_RQ.cpp}
    \subsubsection{Pointer-based, Range-update Segment Tree}
      \code{data-structures/segtree_rec_RU_RQ.cpp}
    \subsubsection{Array-based, Range-update Segment Tree}
      \code{data-structures/segtree_array_lazy.cpp}
    \subsubsection{Array-based, Point-update, Persistent Segment Tree}
      \code{data-structures/segtree_persistent_iter.cpp}
    \subsubsection{Pointer-based, Point-update, Persistent Segment Tree}
      \code{data-structures/segtree_persistent_rec.cpp}
    \subsubsection{2D Segment Tree}
      \code{data-structures/segtree_2d.cpp}
  \subsection{Treap}
		\subsubsection{Implicit Treap}
			\code{data-structures/treap_implicit.cpp}
		\subsubsection{Persistent Treap}
  \subsection{Splay Tree}
    \code{data-structures/splay.cpp}
	\subsection{Ordered Statistics Tree}
    \code{data-structures/ordered_statistics_tree.cpp}
	\subsection{Sparse Table}
    \subsubsection{1D Sparse Table}
      \code{data-structures/sparse.cpp}
    \subsubsection{2D Sparse Table}
      \code{data-structures/sparse_2d.cpp}
  \subsection{Misof Tree}
    A simple tree data structure for inserting, erasing, and querying the nth largest element.
    \code{data-structures/misof_tree.cpp}
\section{Graphs}
	Using adjacency list:
	\code{graphs/graph_template_adjlist.cpp}
	Using adjacency matrix:
	\code{graphs/graph_template_adjmat.cpp}
	Using edge list:
	\code{graphs/graph_template_edgelist.cpp}
	\subsection{Single-Source Shortest Paths}
		\subsubsection{Dijkstra}
			\code{graphs/shortest_paths/dijkstra.cpp}
		\subsubsection{Bellman-Ford}
			\code{graphs/shortest_paths/bellman_ford.cpp}
    \subsubsection{SPFA}
      \code{graphs/shortest_paths/spfa.cpp}
	\subsection{All-Pairs Shortest Paths}
		\subsubsection{Floyd-Washall}
			\code{graphs/shortest_paths/floyd_warshall.cpp}
	\subsection{Strongly Connected Components}
		\subsubsection{Kosaraju}
      \code{graphs/scc/kosaraju.cpp}
    \subsubsection{Tarjan's Offline Algorithm}
      \code{graphs/scc/tarjan.cpp}
  \subsection{Minimum Mean Weight Cycle}
    Run this for each strongly connected component
    \code{graphs/min_mean_cycle.cpp}
	\subsection{Biconnected Components}
	  \subsubsection{Cut Points, Bridges, and Block-Cut Tree}
      \code{graphs/bridges_artics.cpp}
		\subsubsection{Bridge Tree}
      Run the bridge finding algorithm first, burn the bridges, compress the
      remaining biconnected components, and then connect them using the bridges.
	\subsection{Minimum Spanning Tree}
		\subsubsection{Kruskal}
      \code{graphs/mst/kruskal.cpp}
		\subsubsection{Prim}
      \code{graphs/mst/prim.cpp}
	\subsection{Euler Path/Cycle}
    \subsubsection{Euler Path/Cycle in a Directed Graph}
      \code{graphs/euler_path.cpp}
    \subsubsection(Euler Path/Cycle in an Undirected Graph)
      \code{graphs/euler_path_undirected.cpp}
	\subsection{Bipartite Matching}
		\subsubsection{Alternating Paths Algorithm}
      \code{graphs/bipartite_matching/bipartite_matching.cpp}
		\subsubsection{Hopcroft-Karp Algorithm}
      \code{graphs/bipartite_matching/hopcroft_karp.cpp}
    \subsubsection{Minimum Vertex Cover in Bipartite Graphs}
      \code{graphs/bipartite_matching/bipartite_mvc.cpp}
	\subsection{Maximum Flow}
		\subsubsection{Edmonds-Karp}
			\code{graphs/max_flow/edmonds_karp.cpp}
		\subsubsection{Dinic}
			\code{graphs/max_flow/dinic.cpp}
  \subsection{All-pairs Maximum Flow}
    \subsubsection{Gomory-Hu}
      \code{graphs/max_flow/gomory_hu_tree.cpp}
  \subsection{Minimum Arborescence}
    Given a weighted directed graph, finds a subset of edges of minimum
    total weight so that there is a unique path from the root $r$ to each
    vertex. Returns a vector of size $n$, where the $i$th element is the
    edge for the $i$th vertex. The answer for the root is undefined!
    \code{graphs/arborescence.cpp}
  \subsection{Blossom algorithm}
    Finds a maximum matching in an arbitrary graph in $O(|V|^4)$ time. Be
    vary of loop edges.
    \code{graphs/blossom.cpp}
  \subsection{Maximum Density Subgraph}
    Given (weighted) undirected graph $G$. Binary search density. If $g$ is
    current density, construct flow network: $(S, u, m)$, $(u, T,
    m+2g-d_u)$, $(u,v,1)$, where $m$ is a large constant (larger than sum
    of edge weights). Run floating-point max-flow. If minimum cut has empty
    $S$-component, then maximum density is smaller than $g$, otherwise it's
    larger. Distance between valid densities is at least $1/(n(n-1))$. Edge
    case when density is $0$. This also works for weighted graphs by
    replacing $d_u$ by the weighted degree, and doing more iterations (if
    weights are not integers).
  \subsection{Maximum-Weight Closure}
    Given a vertex-weighted directed graph $G$. Turn the graph into a flow
    network, adding weight $\infty$ to each edge. Add vertices $S,T$. For
    each vertex $v$ of weight $w$, add edge $(S,v,w)$ if $w\geq 0$, or edge
    $(v,T,-w)$ if $w<0$. Sum of positive weights minus minimum $S-T$ cut is
    the answer. Vertices reachable from $S$ are in the closure. The
    maximum-weight closure is the same as the complement of the
    minimum-weight closure on the graph with edges reversed.
  \subsection{Maximum Weighted Independent Set in a Bipartite Graph}
    This is the same as the minimum weighted vertex cover. Solve this by
    constructing a flow network with edges $(S,u,w(u))$ for $u\in L$,
    $(v,T,w(v))$ for $v\in R$ and $(u,v,\infty)$ for $(u,v)\in E$. The
    minimum $S,T$-cut is the answer. Vertices adjacent to a cut edge are
    in the vertex cover.
  \subsection{Synchronizing word problem}
    A DFA has a synchronizing word (an input sequence that moves all states
    to the same state) iff.\ each pair of states has a synchronizing word.
    That can be checked using reverse DFS over pairs of states. Finding the
    shortest synchronizing word is NP-complete.
  \subsection{Max flow with lower bounds on edges}
    % TODO: Test this!
    Change edge $(u,v,l\leq f\leq c)$ to $(u,v,f\leq c-l)$. Add edge
    $(t,s,\infty)$. Create super-nodes $S$, $T$. Let $M(u) = \sum_{v}
    l(v,u) - \sum_{v} l(u,v)$. If $M(u)<0$, add edge $(u,T,-M(u))$, else
    add edge $(S,u,M(u))$. Max flow from $S$ to $T$. If all edges from $S$
    are saturated, then we have a feasible flow. Continue running max flow
    from $s$ to $t$ in original graph.
    % TODO: Was there something similar for vertex capacities that we should add?
  \subsection{Tutte matrix for general matching}
    Create an $n\times n$ matrix $A$. For each edge $(i,j)$, $i<j$, let
    $A_{ij} = x_{ij}$ and $A_{ji} = -x_{ij}$. All other entries are $0$.
    The determinant of $A$ is zero iff.\ the graph has a perfect matching.
    A randomized algorithm uses the Schwartz--Zippel lemma to check if it is
    zero.
  \subsection{Heavy Light Decomposition}
    \code{graphs/heavy_light_decomposition.cpp}
	\subsection{Centroid Decomposition}
    \code{graphs/centroid_decomposition.cpp}
	\subsection{Least Common Ancestor}
		\subsubsection{Binary Lifting}
      \code{graphs/lca/binary_lifting.cpp}
  \subsection{Counting Spanning Trees}
    Kirchoff's Theorem: The number of spanning trees of any graph is the
    determinant of any cofactor of the Laplacian matrix in $O(n^3)$.
    \begin{enumerate}
        \item Let $A$ be the adjacency matrix.
        \item Let $D$ be the degree matrix (matrix with vertex degrees on the diagonal).
        \item Get $D-A$ and delete exactly one row and column. Any row and
        column will do. This will be the cofactor matrix.
        \item Get the determinant of this cofactor matrix using Gauss-Jordan.
        \item $\text{Spanning Trees} = \left|\mathrm{cofactor}(D-A) \right|$
    \end{enumerate}
  \subsection{Erd\H{o}s-Gallai Theorem}
    A sequence of non-negative integers $d_1 \ge \cdots \ge d_n$ can be represented as the
    degree sequence of finite simple graph on $n$ vertices if and only if $d_1 + \cdots + d_n$ is
    even and the following holds for $1 \le k \le n$:
    \[
    \sum_{i=1}^n d_i \le k(k-1) + \sum_{i=k+1}^n \min\left(d_i, k\right)
    \]
  \subsection{Tree Isomorphism}
    \code{graphs/tree_isomorphism.cpp}
\section{Strings}
  \subsection{Knuth-Morris-Pratt}
    Count and find all matches of string $f$ in string $s$ in $O(n)$ time.
    \code{strings/kmp.cpp}
  \subsection{Trie}
    \code{strings/trie.cpp}
  \subsection{Suffix Array}
    Construct a sorted catalog of all substrings of $s$ in $O(n \log n)$ time using counting sort.
    \code{strings/suffix-array.cpp}
  \subsection{Longest Common Prefix}
    Find the length of the longest common prefix for every substring in $O(n)$.
    \code{strings/lcp.cpp}
  \subsection{Aho-Corasick Trie}
    Find all multiple pattern matches in $O(n)$ time. This is KMP for multiple strings.
    \code{strings/aho-corasick-trie.java}
  \subsection{Palindromic Tree}
    Find lengths and frequencies of all palindromic substrings of a string in $O(n)$ time.

    Theorem: there can only be up to $n$ unique palindromic substrings for any string.
    \code{strings/palindromic-tree.cpp}
  \subsection{Z Algorithm}
    Find the longest common prefix of all substrings of $s$ with itself in $O(n)$ time.
    \code{strings/z.cpp}
  \subsection{Booth's Minimum String Rotation}
    Booth's Algo: Find the index of the lexicographically least string rotation in $O(n)$ time.
    \code{strings/booth.cpp}
	\subsection{Hashing}
    \subsubsection{Polynomial Hashing}
      \code{strings/polynomial_hashing.cpp}
\section{Number Theory}
	\subsection{Eratosthenes Prime Sieve}
    \code{numtheory/prime-sieve.cpp}
  \subsection{Divisor Sieve}
    \code{numtheory/divisor-sieve.cpp}
  \subsection{Number/Sum of Divisors}
    If a number $n$ is prime factorized where $n = {p_1}^{e_1} \times {p_2}^{e_2} \times \cdots \times {p_k}^{e_k}$, where $\sigma_0$ is the number of divisors while $\sigma_1$ is the sum of divisors:
    \[
    \sum_{d\mid n} d^k = \sigma_k (n) = \prod \frac{{p_i}^{k(e_i)+1}-1}{p_i -1}
    \]
    \[
    \text{Product: } \prod_{d\mid n} d = n^{\frac{\sigma_1 (n)}{2}}
    \]
  \subsection{M\"{o}bius Sieve}
    The M\"{o}bius function $\mu$ is the M\"{o}bius inverse of $e$ such that $e(n) = \sum_{d\mid n} \mu(d)$.
    \code{numtheory/moebius-sieve.cpp}
  \subsection{M\"{o}bius Inversion}
    Given arithmetic functions $f$ and $g$:
    \[
    g(n) = \sum_{d\mid n} f(d) \quad \Leftrightarrow \quad f(n) = \sum_{d\mid n} \mu(d)\; g\left(\frac{n}{d}\right)
    \]
  \subsection{GCD Subset Counting}
    Count number of subsets $S \subseteq A$ such that $\gcd(S) = g$ (modifiable).
    \code{numtheory/gcd-subsets.cpp}
  \subsection{Euler Totient}
    Counts all integers from 1 to $n$ that are relatively prime to $n$ in $O(\sqrt{n})$ time.
    \code{numtheory/totient.cpp}
  \subsection{Euler Phi Sieve}
    Sieve version of Euler totient, runs in $O(N \log N)$ time. Note that $n = \sum_{d\mid n} \varphi(d)$.
    \code{numtheory/phi-sieve.cpp}
  \subsection{Extended Euclidean}
    Assigns $x,y$ such that $ax + by = \gcd(a,b)$ and returns $\gcd(a,b)$.
    \code{numtheory/extended-euclidean.cpp}
  \subsection{Modular Exponentiation}
    Find $b^e \pmod m$ in $O(log e)$ time.
    \code{numtheory/mod_pow.cpp}
  \subsection{Modular Inverse}
    Find unique $x$ such that $ax \equiv 1 \pmod m$. Returns 0 if no unique solution is found. \underline{Please use modulo solver for the non-unique case.}
    \code{numtheory/modinv.cpp}
  \subsection{Modulo Solver}
    Solve for values of $x$ for $ax \equiv b \pmod m$. Returns $(-1,-1)$ if there is no solution. Returns a pair $(x, M)$ where solution is $x \bmod M$.
    \code{numtheory/modsolver.cpp}
  \subsection{Linear Diophantine}
    Computes integers $x$ and $y$ such that $ax+by=c$, returns $(-1,-1)$ if no solution. \underline{Tries to return positive integer answers for $x$ and $y$ if possible.}
    \code{numtheory/linear-diophantine.cpp}
  \subsection{Chinese Remainder Theorem}
    Solves linear congruence $x \equiv b_i \pmod {m_i}$. Returns $(-1,-1)$ if there is no solution. Returns a pair $(x, M)$ where solution is $x \bmod M$.
    \code{numtheory/chinese-remainder.cpp}
    \subsubsection{Super Chinese Remainder}
      Solves linear congruence $a_i x \equiv b_i \pmod {m_i}$. Returns $(-1,-1)$ if there is no solution.
      \code{numtheory/super-crt.cpp}
  \subsection{Primitive Root}
    \code{numtheory/primitive_root.cpp}
  \subsection{Josephus}
    Last man standing out of $n$ if every $kth$ is killed. Zero-based, and does not kill $0$ on first pass.
    \code{numtheory/josephus.cpp}
  \subsection{Number of Integer Points under a Lines}
    Count the number of integer solutions to $Ax+By \leq C$, $0 \leq x \leq n$,
    $0 \leq y$. In other words, evaluate the sum $\sum_{x=0}^n\left\lfloor\dfrac{C-Ax}{B}+1\right\rfloor$.
    To count all solutions, let $n = \left\lfloor\dfrac{c}{a}\right\rfloor$.
    In any case, it must hold that $C-nA \geq 0$. Be very careful about overflows.
\section{Algebra}
  \subsection{Fast Fourier Transform}
    Compute the Discrete Fourier Transform (DFT) of a polynomial in $O(n \log n)$ time.
    \code{algebra/fft.cpp}
  \subsection{FFT Polynomial Multiplication}
    Multiply integer polynomials $a, b$ of size $an, bn$ using FFT in $O(n \log n)$. Stores answer in an array $c$, rounded to the nearest integer (or double).
    \code{algebra/fft-poly-mul.cpp}
  \subsection{Number Theoretic Transform}
    Other possible moduli: $2 113 929 217 (2^{25}), 2 013 265 920 268 435 457 (2^{28}, with g = 5)$
    \code{algebra/ntt.cpp}
  \subsection{Polynomial Long Division}
    Divide two polynomials $A$ and $B$ to get $Q$ and $R$, where $\frac{A}{B} = Q + \frac{R}{B}$.
    \code{algebra/poly-long-div.cpp}
  \subsection{Matrix Multiplication}
    Multiplies matrices $A_{p\times q}$ and $B_{q\times r}$ in $O(n^3)$ time, modulo \texttt{MOD}.
    \code{algebra/matmul.java}
  \subsection{Matrix Power}
    Computes for $B^e$ in $O(n^3 \log e)$ time. Refer to Matrix Multiplication.
    \code{algebra/matpow.java}
  \subsection{Fibonacci Matrix}
    Fast computation for $n$th Fibonacci $\left\{F_1,F_2,\ldots,F_n \right\}$ in $O(\log n)$:
    \[
    \begin{bmatrix}
        F_n \\
        F_{n-1}
    \end{bmatrix}
    =
    \begin{bmatrix}
        1 & 1 \\
        1 & 0
    \end{bmatrix}^n
    \times
    \begin{bmatrix}
        F_2 \\
        F_1
    \end{bmatrix}
    \]
  \subsection{Gauss-Jordan/Matrix Determinant}
    Row reduce matrix $A$ in $O(n^3)$ time. Returns \texttt{true} if a solution exists.
    \code{algebra/gauss-jordan.java}
\section{Combinatorics}
  \subsection{Lucas Theorem}
    Compute $\binom{n}{k} \bmod{p}$ in $O(p + \log_p n)$ time, where $p$ is a prime.
    \code{combs/lucas.cpp}
  \subsection{Granville's Theorem}
    Compute $\binom{n}{k} \bmod{m}$ (for any $m$) in $O(m^2 \log^2 n)$ time.
    \code{combs/granville.py}
  \subsection{Derangements}
    Compute the number of permutations with $n$ elements such that no element is at their original position:
    \[
    D(n) = (n-1) \left( D(n-1) + D(n-2) \right) =  n D(n-1) + (-1)^n
    \]
    % \subsection{Next Permutation}
    % \subsection{Next Combination}
    % \subsection{Next Arrangement}
    % \subsection{Next Partition}
    \subsection{Factoradics}
    Convert a permutation of $n$ items to factoradics and vice versa in $O(n \log n)$.
    \code{combs/factoradics.cpp}
  \subsection{$k$th Permutation}
    Get the next $k$th permutation of $n$ items, if exists, using factoradics. All values should be from $0$ to $n-1$. Use factoradics methods as discussed above.
    \code{combs/kth-permutation.cpp}
  \subsection{Catalan Numbers}
    \[
        C_n = \frac{1}{n+1}\binom{2n}{n} =  \binom{2n}{n}-\binom{2n}{n+1}
    \]
    \begin{enumerate}
      \item The number of non-crossing partitions of an $n$-element set
      \item The number of expressions with $n$ pairs of parentheses
      \item The number of ways $n+1$ factors can be parenthesized
      \item The number of full binary trees with $n+1$ leaves
      \item The number of monotonic lattice paths of an $n \times n$ grid (5-SAT problem)
      \item The number of triangulations of a convex polygon with $n+2$ sides (non-rotational)
      \item The number of permutations $\{1, \ldots, n\}$ without a 3-term increasing subsequence
      \item The number of ways to form a mountain range with $n$ ups and $n$ downs
    \end{enumerate}
  \subsection{Stirling Numbers}
    $s_1$: Count the number of permutations of $n$ elements with $k$ disjoint cycles

    $s_2$: Count the ways to partition a set of $n$ elements into $k$ nonempty subsets
    \[
    s_1(n,k) = \begin{cases}
        1 & n = k = 0 \\
        s_1(n-1,k-1) - (n-1) s_1(n-1,k) & n,k>0 \\
        0 & \text{elsewhere}
    \end{cases}
    \]
    \[
    s_2(n,k) = \begin{cases}
        1 & n = k = 0 \\
        s_2(n-1,k-1) + k s_2(n-1,k) & n,k>0 \\
        0 & \text{elsewhere}
    \end{cases}
    \]
  \subsection{Partition Function}
    Pregenerate the number of partitions of positive integer $n$ with $n$ positive addends.
    \[
    p(n,k) = \begin{cases}
        1 & n = k = 0 \\
        0 & n < k \\
        p(n-1,k-1) + p(n-k,k) & n \ge k
    \end{cases}
    \]
\section{Geometry}
  \code{geom/compgeom.cpp}
	\subsection{Dots and Cross Products}
    \code{geom/dot-cross.cpp}
  \subsection{Angles and Rotations}
    \code{geom/angles-rots.cpp}
	\subsection{Spherical Coordinates}
    \[
        \begin{array}{cc}
            x = r \cos \theta \cos \phi & r = \sqrt{x^2 + y^2 + z^2} \\
            y = r \cos \theta \sin \phi & \theta = \cos^{-1} x/r \\
            z = r \sin \theta & \phi = \mathrm{atan2}(y,x)
        \end{array}
    \]
	\subsection{Point Projection}
    \code{geom/pt-proj.cpp}
	\subsection{Great Circle Distance}
    \code{geom/great-circle.cpp}
	\subsection{Point/Line/Plane Distances}
    \code{geom/dists.cpp}
	\subsection{Intersections}
    \subsubsection{Line-Segment Intersection}
      Get intersection points of 2D lines/segments $\overline{ab}$ and $\overline{cd}$.
      \code{geom/line-seg-isect.cpp}
    \subsubsection{Circle-Line Intersection}
      Get intersection points of circle at center $c$, radius $r$, and line $\overline{ab}$.
      \code{geom/circ-line-isect.cpp}
    \subsubsection{Circle-Circle Intersection}
      \code{geom/circ-circ-isect.cpp}
	\subsection{Polygon Areas}
    Find the area of any 2D polygon given as points in $O(n)$.
    \code{geom/poly-area.cpp}
    \subsubsection{Triangle Area}
      Find the area of a triangle using only their lengths. Lengths must be valid.
      \code{geom/tri-area.cpp}
    \subsubsection*{Cyclic Quadrilateral Area}
      Find the area of a cyclic quadrilateral using only their lengths. A quadrilateral is
      cyclic if its inner angles sum up to $360^\circ$.
      \code{geom/cyc-quad-area.cpp}
  \subsection{Polygon Centroid}
    Get the centroid/center of mass of a polygon in $O(m)$.
    \code{geom/poly-centroid.cpp}
  \subsection{Convex Hull}
    Get the convex hull of a set of points using Graham-Andrew's scan. This sorts the
    points at $O(n \log n)$, then performs the Monotonic Chain Algorithm at $O(n)$.
    \code{geom/convex-hull.cpp}
  \subsection{Point in Polygon}
    Check if a point is strictly inside (or on the border) of a polygon in $O(n)$.
    \code{geom/pt-in-poly.cpp}
  \subsection{Cut Polygon by a Line}
    Cut polygon by line $\overline{ab}$ to its left in $O(n)$, such that $\angle abp$ is counter-clockwise.
    \code{geom/cut-poly.cpp}
  \subsection{Triangle Centers}
    \code{geom/tri-centers.cpp}
  \subsection{Convex Polygon Intersection}
    Get the intersection of two convex polygons in $O(n^2)$.
    \code{geom/convex-poly-isect.cpp}
  \subsection{Pick's Theorem for Lattice Points}
    Count points with integer coordinates inside and on the boundary of a polygon in
    $O(n)$ using Pick's theorem: $\text{Area} = I + B/2 - 1$.
    \code{geom/picks.cpp}
  \subsection{Minimum Enclosing Circle}
    Get the minimum bounding ball that encloses a set of points (2D or 3D) in $\Theta{n}$.
    \code{geom/min-enclosing-circ.cpp}
  \subsection{Shamos Algorithm}
    Solve for the polygon diameter in $O(n \log n)$.
    \code{geom/shamos.cpp}
  \subsection{$k$D Tree}
    Get the $k$-nearest neighbors of a point within pruned radius in $O(k \log k \log n)$.
    \code{geom/kd-tree.cpp}
  \subsection{Line Sweep (Closest Pair)}
    Get the closest pair distance of a set of points in $O(n \log n)$ by sweeping a line and
    keeping a bounded rectangle. Modifiable for other metrics such as Minkowski and
    Manhattan distance. For external point queries, see $k$D Tree.
    \code{geom/closest-pair.cpp}
  \subsection{Line upper/lower envelope}
    To find the upper/lower envelope of a collection of lines $a_i+b_i x$,
    plot the points $(b_i,a_i)$, add the point $(0,\pm \infty)$ (depending
    on if upper/lower envelope is desired), and then find the convex hull.
  \subsection{Formulas}
    Let $a = (a_x, a_y)$ and $b = (b_x, b_y)$ be two-dimensional vectors.
    \begin{itemize}
      \item $a\cdot b = |a||b|\cos{\theta}$, where $\theta$ is the angle
        between $a$ and $b$.
      \item $a\times b = |a||b|\sin{\theta}$, where $\theta$ is the
        signed angle between $a$ and $b$.
      \item $a\times b$ is equal to the area of the parallelogram with
        two of its sides formed by $a$ and $b$. Half of that is the
        area of the triangle formed by $a$ and $b$.
      \item The line going through $a$ and $b$ is $Ax+By=C$ where $A=b_y-a_y$, $B=a_x-b_x$, $C=Aa_x+Ba_y$.
      \item Two lines $A_1x+B_1y=C_1$, $A_2x+B_2y=C_2$ are parallel iff.\ $D=A_1B_2-A_2B_1$ is zero. Otherwise their unique intersection is $(B_2C_1-B_1C_2,A_1C_2-A_2C_1)/D$.
      \item \textbf{Euler's formula:} $V - E + F = 2$
      \item Side lengths $a,b,c$ can form a triangle iff.\ $a+b>c$, $b+c>a$ and $a+c>b$.
      \item Sum of internal angles of a regular convex $n$-gon is $(n-2)\pi$.
      \item \textbf{Law of sines:} $\frac{a}{\sin A} = \frac{b}{\sin B} = \frac{c}{\sin C}$
      \item \textbf{Law of cosines:} $b^2 = a^2 + c^2 - 2ac\cos B$
      \item Internal tangents of circles $(c_1,r_1), (c_2,r_2)$ intersect at $(c_1r_2+c_2r_1)/(r_1+r_2)$, external intersect at $(c_1r_2-c_2r_1)/(r_1+r_2)$.
    \end{itemize}
\section{Other Algorithms}
  \subsection{2SAT}
    \ifverbose
    A fast 2SAT solver.
    \fi
    \code{other/two_sat.cpp}
  \subsection{DPLL Algorithm}
    A SAT solver that can solve a random 1000-variable SAT instance within a second.
    \code{other/dpll.cpp}
  \subsection{Dynamic Convex Hull Trick}
    \code{other/dynamic-ch-trick.cpp}
  \subsection{Stable Marriage}
    \ifverbose
    The Gale-Shapley algorithm for solving the stable marriage problem.
    \fi
    \code{other/stable_marriage.cpp}
  \subsection{Algorithm X}
    \ifverbose
    An implementation of Knuth's Algorithm X, using dancing links. Solves the Exact Cover problem.
    \fi
    \code{other/algorithm_x.cpp}
  \subsection{Matroid Intersection}
    Computes the maximum weight and cardinality intersection of two
    matroids, specified by implementing the required abstract methods, in
    $O(n^3(M_1+M_2))$.
    \code{other/matroid_intersection.cpp}
  \subsection{$n$th Permutation}
    \ifverbose
    A very fast algorithm for computing the $n$th permutation of the list
    $\{0,1,\ldots,k-1\}$.
    \fi
    \code{other/nth_permutation.cpp}
  \subsection{Cycle-Finding}
    \ifverbose
    An implementation of Floyd's Cycle-Finding algorithm.
    \fi
    \code{other/floyds_algorithm.cpp}
  \subsection{Longest Increasing Subsequence}
    \code{other/lis.cpp}
  \subsection{Dates}
    \ifverbose
    Functions to simplify date calculations.
    \fi
    \code{other/dates.cpp}
  \subsection{Simulated Annealing}
    An example use of Simulated Annealing to find a permutation of length $n$
    that maximizes $\sum_{i=1}^{n-1}|p_i - p_{i+1}|$.
    \code{other/simulated_annealing.cpp}
  \subsection{Simplex}
    \code{other/simplex.cpp}
  \subsection{Fast Square Testing}
    An optimized test for square integers.
    \code{tricks/is_square.cpp}
  \subsection{Fast Input Reading}
    If input or output is huge, sometimes it is beneficial to optimize the
    input reading/output writing. This can be achieved by reading all input
    in at once (using fread), and then parsing it manually. Output can also
    be stored in an output buffer and then dumped once in the end (using
    fwrite). A simpler, but still effective, way to achieve speed is to use
    the following input reading method.
    \code{tricks/fast_input.cpp}
  \subsection{128-bit Integer}
    GCC has a 128-bit integer data type named \texttt{\_\_int128}. Useful
    if doing multiplication of 64-bit integers, or something needing a
    little more than 64-bits to represent. There's also
    \texttt{\_\_float128}.
  \subsection{Bit Hacks}
    \code{tricks/snoob.cpp}
\newpage
\section{Other Combinatorics Stuff}
  \begin{tabular}{@{}l|l|l@{}}
  \toprule
  Catalan	&	$C_0=1$, $C_n=\frac{1}{n+1}\binom{2n}{n} = \sum_{i=0}^{n-1}C_iC_{n-i-1} = \frac{4n-2}{n+1}C_{n-1}$  & \\
  Stirling 1st kind & $\left[{0\atop 0}\right]=1$, $\left[{n\atop 0}\right]=\left[{0\atop n}\right]=0$, $\left[{n\atop k}\right]=(n-1)\left[{n-1\atop k}\right]+\left[{n-1\atop k-1}\right]$ & \#perms of $n$ objs with exactly $k$ cycles\\
  Stirling 2nd kind & $\left\{{n\atop 1}\right\}=\left\{{n\atop n}\right\}=1$, $\left\{{n\atop k}\right\} = k \left\{{ n-1 \atop k }\right\} + \left\{{n-1\atop k-1}\right\}$ & \#ways to partition $n$ objs into $k$ nonempty sets\\
  Euler	& $\left \langle {n\atop 0} \right \rangle = \left \langle {n\atop n-1} \right \rangle = 1 $, $\left \langle {n\atop k} \right \rangle = (k+1) \left \langle {n-1\atop {k}} \right \rangle + (n-k)\left \langle {{n-1}\atop {k-1}} \right \rangle$ & \#perms of $n$ objs with exactly $k$ ascents \\
  Euler 2nd Order &  $\left \langle \!\!\left \langle {n\atop k} \right \rangle \!\! \right \rangle = (k+1) \left \langle \!\! \left \langle {{n-1}\atop {k}} \right \rangle \!\! \right \rangle +(2n-k-1)\left \langle \!\! \left \langle {{n-1}\atop {k-1}} \right \rangle  \!\! \right \rangle$ & \#perms of ${1,1,2,2,...,n,n}$ with exactly $k$ ascents \\
  Bell & $B_1 = 1$, $B_n = \sum_{k=0}^{n-1} B_k \binom{n-1}{k} = \sum_{k=0}^n\left\{{n\atop k}\right\}$ & \#partitions of $1..n$ (Stirling 2nd, no limit on k)\\
  \bottomrule
  \end{tabular}

  \vspace{10pt}
  \begin{tabular}{ll}
    \#labeled rooted trees & $n^{n-1}$ \\
    \#labeled unrooted trees & $n^{n-2}$ \\
    \#forests of $k$ rooted trees & $\frac{k}{n}\binom{n}{k}n^{n-k}$ \\
    % Kirchoff's theorem
    $\sum_{i=1}^n i^2 = n(n+1)(2n+1)/6$ & $\sum_{i=1}^n i^3 = n^2(n+1)^2/4$ \\
    $!n = n\times!(n-1)+(-1)^n$ & $!n = (n-1)(!(n-1)+!(n-2))$ \\
    $\sum_{i=1}^n \binom{n}{i} F_i = F_{2n}$ & $\sum_{i} \binom{n-i}{i} = F_{n+1}$ \\
    $\sum_{k=0}^n \binom{k}{m} = \binom{n+1}{m+1}$ & $x^k = \sum_{i=0}^k i!\stirling{k}{i}\binom{x}{i} = \sum_{i=0}^k \left\langle {k \atop i} \right\rangle\binom{x+i}{k}$ \\

    $a\equiv b\pmod{x,y} \Rightarrow a\equiv b\pmod{\lcm(x,y)}$ & $\sum_{d|n} \phi(d) = n$ \\
    $ac\equiv bc\pmod{m} \Rightarrow a\equiv b\pmod{\frac{m}{\gcd(c,m)}}$ & $(\sum_{d|n} \sigma_0(d))^2 = \sum_{d|n} \sigma_0(d)^3$ \\
    $p$ prime $\Leftrightarrow (p-1)!\equiv -1\pmod{p}$ & $\gcd(n^a-1,n^b-1) = n^{\gcd(a,b)}-1$ \\
    $\sigma_x(n) = \prod_{i=0}^{r} \frac{p_i^{(a_i + 1)x} - 1}{p_i^x - 1}$ & $\sigma_0(n) = \prod_{i=0}^r (a_i + 1)$ \\
    $\sum_{k=0}^m (-1)^k \binom{n}{k} = (-1)^m \binom{n-1}{m}$ & \\
    $2^{\omega(n)} = O(\sqrt{n})$ & $\sum_{i=1}^n 2^{\omega(i)} = O(n \log n)$ \\
    % Kinematic equations
    $d = v_i t + \frac{1}{2}at^2$ & $v_f^2 = v_i^2 + 2ad$ \\
    $v_f = v_i + at$ & $d = \frac{v_i + v_f}{2}t$ \\
  \end{tabular}
  \subsection{The Twelvefold Way}
    Putting $n$ balls into $k$ boxes.\\
  \begin{tabular}{@{}c|c|c|c|c|l@{}}
  Balls & same & distinct & same & distinct & \\
  Boxes & same & same & distinct & distinct & Remarks\\
  \hline
    - & $\mathrm{p}_k(n)$ & $\sum_{i=0}^k \stirling{n}{i}$ & $\binom{n+k-1}{k-1}$ & $k^n$ & $\mathrm{p}_k(n)$: \#partitions of $n$ into $\le k$ positive parts \\
    $\mathrm{size}\ge 1$ & $\mathrm{p}(n,k)$ & $\stirling{n}{k}$ & $\binom{n-1}{k-1}$ & $k!\stirling{n}{k}$ & $\mathrm{p}(n,k)$: \#partitions of $n$ into $k$ positive parts \\
    $\mathrm{size}\le 1$ & $[n \le k]$ & $[n \le k]$ & $\binom{k}{n}$ & $n!\binom{k}{n}$ & $[cond]$: $1$ if $cond=true$, else $0$\\
  \bottomrule
  \end{tabular}

\clearpage

\input{useful_info}

\end{multicols*}

\end{document}
